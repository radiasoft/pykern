"""HTTP server & client

:copyright: Copyright (c) 2024 RadiaSoft LLC.  All Rights Reserved.
:license: http://www.apache.org/licenses/LICENSE-2.0.html
"""

from pykern.pkcollections import PKDict
from pykern.pkdebug import pkdc, pkdlog, pkdp, pkdexc, pkdformat
import inspect
import msgpack
import pykern.pkasyncio
import pykern.pkcollections
import pykern.pkconfig
import pykern.quest
import re
import tornado.httpclient
import tornado.web
import tornado.websocket


#: Http auth header name
_AUTH_HEADER = "Authorization"

#: http auth header scheme bearer
_AUTH_HEADER_SCHEME_BEARER = "Bearer"

#: POSIT: Matches anything generated by `unique_key`
_UNIQUE_KEY_CHARS_RE = r"\w+"

#: validates auth secret (only word chars)
_AUTH_SECRET_RE = re.compile(f"^{_UNIQUE_KEY_CHARS_RE}$")

#: Regex to test format of auth header and extract token
_AUTH_HEADER_RE = re.compile(
    _AUTH_HEADER_SCHEME_BEARER + r"\s+(" + _UNIQUE_KEY_CHARS_RE + ")",
    re.IGNORECASE,
)

_VERSION_HEADER = "X-PyKern-HTTP-Version"

_VERSION_HEADER_VALUE = "1"

_API_NAME_RE = re.compile(rf"^{pykern.quest.API.METHOD_PREFIX}(\w+)")


def server_start(api_classes, attr_classes, http_config, coros=()):
    """Start the `_HTTPServer` in asyncio

    Args:
        api_classes (Iterable): `pykern.quest.API` subclasses to be dispatched
        attr_classes (Iterable): `pykern.quest.Attr` subclasses to create API instance
        http_config (PKDict): auth_secret and `pkasyncio.Loop.http_server` arg
        coros (Iterable): list of coroutines to be passed to `pkasyncio.Loop.run`
    """
    l = pykern.pkasyncio.Loop()
    _HTTPServer(l, api_classes, attr_classes, http_config)
    if coros:
        l.run(*coros)
    l.start()


class Reply:

    def __init__(self, result=None, exc=None, api_error=None):
        def _exception(exc):
            if exc is None:
                pkdlog("ERROR: no reply and no exception")
                return 500
            if isinstance(exc, APINotFound):
                return 404
            if isinstance(exc, APIForbidden):
                return 403
            pkdlog("untranslated exception={}", exc)
            return 500

        if isinstance(result, Reply):
            self.http_status = result.http_status
            self.content = result.content
        elif result is not None or api_error is not None:
            self.http_status = 200
            self.content = PKDict(
                api_error=api_error,
                api_result=result,
            )
        else:
            self.http_status = _exception(exc)
            self.content = None


class ReplyExc(Exception):
    """Raised to end the request.

    Args:
        pk_args (dict): exception args that are specific to this module
        log_fmt (str): server side log data
    """

    def __init__(self, *args, **kwargs):
        super().__init__()
        if "pk_args" in kwargs:
            self.pk_args = kwargs["pk_args"]
            del kwargs["pk_args"]
        else:
            self.pk_args = PKDict()
        if args or kwargs:
            kwargs["pkdebug_frame"] = inspect.currentframe().f_back.f_back
            pkdlog(*args, **kwargs)

    def __repr__(self):
        a = self.pk_args
        return "{}({})".format(
            self.__class__.__name__,
            ",".join(
                ("{}={}".format(k, a[k]) for k in sorted(a.keys())),
            ),
        )

    def __str__(self):
        return self.__repr__()


class APIForbidden(ReplyExc):
    """Raised for forbidden or protocol error"""

    pass


class APINotFound(ReplyExc):
    """Raised for an object not found"""

    pass

class APIDisconnected(ReplyExc):
    """Raised when remote server closed or other error"""

    pass


class HTTPClient:
    """Wrapper for `tornado.httpclient.AsyncHTTPClient`

    Maybe called as an async context manager

    `http_config.request_config` is deprecated.

    Args:
        http_config (PKDict): tcp_ip, tcp_port, api_uri, auth_secret

    """

    def __init__(self, http_config):
        self.uri = (
            f"http://{http_config.tcp_ip}:{http_config.tcp_port}{http_config.api_uri}"
        )
        self.auth_secret = _auth_secret(http_config.auth_secret)
        self._connection = None
        self._destroyed = False
        self._call_id = 0
        self._reader = None
        self._pending_calls = PKDict()

    async def connect(self):
        if self._destroyed:
            raise AssertionError("destroyed")
        if self._connection:
            raise AssertionError("already connected")
        self._connection = await tornado.websocket.websocket_connect(
            tornado.httpclient.HTTPRequest(
                self.uri,
                {
                    _AUTH_HEADER: f"{_AUTH_HEADER_SCHEME_BEARER} {self.auth_secret}",
                    _VERSION_HEADER: _VERSION_HEADER_VALUE,
                },
            )
            #TODO(robnagler) accept in http_config. share defaults with sirepo.job.
            max_message_size=int(2e8),
            ping_interval=120,
            ping_timeout=240,
        )
        self._reader = asyncio.create_task(self._read_loop())

    async def call_api(self, api_name, api_args):
        """Make a request to the API server

        Args:
            api_name (str): what to call on the server
            api_args (PKDict): passed verbatim to the API on the server.
        Returns:
            str: value of `api_result`.
        Raises:
           APIError: if there was an raise in the API or on a server protocol violation
           Exception: other exceptions that `AsyncHTTPClient.fetch` may raise, e.g. NotFound
        """
        def _send():
            self._call_id += 1
            rv = _HTTPClientCall(api_name, api_args, self._call_id)
            self._pending_reqs[r.call_id] = rv
            self._connection.write_message(rv.msg())
            return rv

        # TODO(robnagler) backwards compatibility
        if not self._connection:
            # Does destroy check
            await self.connect()
        c = _send()
        return await c.get_reply()

    def destroy(self):
        """Must be called"""
        if self._destroyed:
            return
        self._destroyed = True
        if self._connection:
            self._connection.close()
            self._connection = None
        x = self._pending_apis
        self._pending_apis = None
        for r in x.values():
            #TODO(robnagler) refine set error class
            r.reply_q.put_nowait(None)

    async def __aenter__(self):
        await self.connect()
        return self

    async def __aexit__(self, *args, **kwargs):
        self.destroy()
        return False

    def _read_loop(self):
        while m := await self._connection.read_message():

        if not self._destroyed:
            # TODO(robnagler)
            self.destroy()



class _HTTPClientReply(PKDict):
    api_error_class
    api_error_args
    def reply(self, msg):

        if msg is None:
            create error reply (closed connection)
        i, c = _unpack_msg(r)
        if e:
            raise pykern.quest.APIError(*e)
        if rv.api_error:
            raise pykern.quest.APIError(
                "api_error={} api_name={} api_args={}", rv.api_error, api_name, api_args
            )


class _HTTPClientCall(PKDict):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        #TODO(robnagler) should be one for regular replies
        self.reply_q = tornado.queues.Queue()
    def reply_put(self, msg):
        if msg is None:
            create error reply (closed connection)

    async def reply_get()
        reply_q.get()
        c.reply_q.task_done()
        c.destroy()

        if not r:
            #TODO(robnagler) refine could be destroyed for other reasons
            # reply_q will be destroyed
            raise APIDisconnected()
        if r.error_class:
            raise r.error_class(r.error_args)
        return r.result


class _HTTPServer:

    def __init__(self, loop, api_classes, attr_classes, http_config):
        def _api_class_funcs():
            for c in api_classes:
                for n, o in inspect.getmembers(c, predicate=inspect.isfunction):
                    yield PKDict(api_class=c, api_func=o, api_func_name=n)

        def _api_map():
            rv = PKDict()
            for a in _api_class_funcs():
                n = a.api_func_name
                if not ((m := _API_NAME_RE.search(n)) and n in a.api_class.__dict__):
                    continue
                a.api_name = m.group(1)
                if a.api_name in rv:
                    raise AssertionError(
                        "duplicate api={a.api_name} class={a.api_class.__name__}"
                    )
                if not inspect.iscoroutinefunction(a.pkdel("api_func")):
                    raise AssertionError(
                        "api_func={n} is not async class={a.api_class.__name__}"
                    )
                rv[a.api_name] = a
            return rv

        h = http_config.copy()
        self.loop = loop
        self.api_map = _api_map()
        self.attr_classes = attr_classes
        self.auth_secret = _auth_secret(h.pkdel("auth_secret"))
        h.uri_map = ((h.api_uri, _WebSocketHandler, PKDict(server=self)),)
        self.api_uri = h.pkdel("api_uri")
        h.log_function = self._log_end
        self._ws_id = 0
        loop.http_server(h)

    def handle_get(self, handler):
        def _authenticate(self, headers):
            if not (h := headers.get(_AUTH_HEADER)):
                return "no auth token"
            if not (m := _AUTH_HEADER_RE.search(h)):
                return "auth token format invalid"
            if m.group(1) != self.auth_secret:
                return "auth token mismatch"
            return None

        def _validate_version(self, headers):
            if not (v := headers.get(_VERSION_HEADER)):
                return f"missing {_VERSION_HEADER} header"
            if v != _VERSION_HEADER_VALUE:
                return f"invalid version {v}"
            return None

        self._log(handler, "start")
        h = handler.request.headers
        if e := self._authenticate(h):
            k = PKDict(status_code=403, reason="Forbidden")
        elif e := self._validate_version(h):
            k = PKDict(status_code=412, reason="Precondition Failed")
        else:
            return True
        handler.pykern_context.error = e
        self.send_error(**k)
        return False

    def handle_open(self, handler):
        self._ws_id += 1
        self.handler.pykern_context.ws_id = self._ws_id
        return _WebSocketConnection(self, handler, ws_id=self._ws_id)


    def _log(self, obj, which, exc=None, reply=None):
        def _add(key, value):
            nonlocal f, a
            if value is not None:
                f += (" " if f else "") + key + "={}"
                a.append(value)

        f = ""
        a = []
        _add("error", obj.pykern_context.get("error"))
        _add("ws_id", obj.pykern_context.get("ws_id"))
        self.loop.http_log(obj, which, f, a)

    def _log_end(self, handler):
        self._log(handler, "end")


class _WebSocketHandler(tornado.websocket.WebSocketHandler):
    def initialize(self, server):
        self.pykern_server = server
        self.pykern_context = PKDict()
        self.pykern_connection = None

    async def get(self, *args, **kwargs):
        if not self.pykern_server.handle_get(self):
            return
        return await super().get(*args, **kwargs)

    async def on_message(self, msg):
        # WebSocketHandler only allows one on_message at a time.
        asyncio.create_task(self.pykern_connection.handle_on_message(msg))

    def on_close(self):
        if self.pykern_connection:
            self.pykern_connection.handle_on_close()
            self.pykern_connection = None

    def open(self):
        self.pykern_connection = self.pykern_server.handle_open(self)


class _WebSocketConnection:

    def __init__(self, server, handler, ws_id):
        self.ws_id = ws_id
        self.server = server
        self.handler = handler
        self._destroyed = False
        self.remote_peer = server.loop.remote_peer(handler)
        self._log(None, "open")

    def destroy(self):
        if self._destroyed:
            return
        self._destroyed = True
        self.handler.close()
        self.handler = None

    def handle_on_close(self):
        if self._destroyed:
            return
        self.handler = None
        self._log(None, "on_close")
        #TODO(robnagler) deal with open requests

    async def handle_on_message(self, msg):
        async def _call(api, api_args):
            with pykern.quest.start(api.api_class, self.server.attr_classes) as qcall:
                return await getattr(qcall, api.api_func_name)(api_args)

        def _reply(call, obj):
            if isinstance(obj, Reply):
                pass
            if isinstance(obj, sirepo.quest.APIError):
                pass
            if isinstance(obj, Exception):
                pass

        c = None
        try:
            c, e = _unpack_msg(msg)
            if e:
                self._log(None, "error", "msg unpack error={}", [e])
                self.destroy()
                return None
            self._log("start", c)
            if not (a := self.server.api_map.get(m.api_name)):
                self._log(c, "error", "api not found={}" m.api_name)
                _reply(c, APINotFound)
            _reply(c, await _call(a, m.api_args))
        except Exception as e:
            _reply(c, e)

    def _log(self, call, which, fmt="", args=None):
        pkdlog(
            "{} ip={} ws={}#{}" + fmt,
            which,
            self.remote_peer,
            self.ws_id,
            call and call.call_id,
            *args,
        )


class _WebSocketMessage():
    def parse_msg(self, msg):
        def _maybe_srunit_caller():
            if pkconfig.in_dev_mode() and (c := self.header.get("srunit_caller")):
                return pkdformat(" srunit={}", c)
            return ""

        if not isinstance(msg, bytes):
            raise AssertionError(f"incoming msg type={type(msg)}")
        u = msgpack.Unpacker(
            max_buffer_size=sirepo.job.cfg().max_message_bytes,
            object_pairs_hook=pkcollections.object_pairs_hook,
        )
        u.feed(msg)
        self.header = u.unpack()
        self.handler.sr_log(
            self,
            "start",
            fmt=" uri={}{}",
            args=[self.header.get("uri"), _maybe_srunit_caller()],
        )
        if sirepo.const.SCHEMA_COMMON.websocketMsg.version != self.header.get(
            "version"
        ):
            raise AssertionError(
                pkdformat("invalid header.version={}", self.header.get("version"))
            )
        # Ensures protocol conforms for all requests
        if (
            sirepo.const.SCHEMA_COMMON.websocketMsg.kind.httpRequest
            != self.header.get("kind")
        ):
            raise AssertionError(
                pkdformat("invalid header.kind={}", self.header.get("kind"))
            )
        self.req_seq = self.header.reqSeq
        self.uri = self.header.uri
        if u.tell() < len(msg):
            self.body_as_dict = u.unpack()
            if u.tell() < len(msg):
                self.attachment = u.unpack()
        # content may or may not exist so defer checking
        e, self.route, self.kwargs = _path_to_route(self.uri[1:])
        if e:
            self.handler.sr_log(
                self,
                "error",
                fmt=" msg={} route={} kwargs={}",
                args=[e, self.route, self.kwargs],
            )
            self.route = _not_found_route

    def set_log_user(self, log_user):
        self.log_user = log_user


def _auth_secret(value):
    if value:
        if len(value) < 16:
            raise ValueError("auth_secret too short len={len(value)} (<16)")
        if not _AUTH_SECRET_RE.search(value):
            raise ValueError("auth_secret contains non-word chars")
        return value
    if pykern.pkconfig.in_dev_mode():
        return "default_dev_secret"
    raise ValueError("must supply http_config.auth_secret")


def _pack_msg(content):
    import datetime

    def _datetime(obj):
        if isinstance(obj, datetime.datetime):
            return int(obj.timestamp())
        return obj

    p = msgpack.Packer(autoreset=False, default=_datetime)
    p.pack(content)
    # TODO(robnagler) getbuffer() would be better
    return p.bytes()


def _unpack_msg(request):
    try:
        u = msgpack.Unpacker(
            object_pairs_hook=pykern.pkcollections.object_pairs_hook,
        )
        u.feed(request.body)
        rv = u.unpack()
    except Exception as e:
        return None, f"msg unpack exception={e}"
    if not isinstance(rv, PKDict):
        return None, f"msg not dict type={type(rv)}"
    if "call_id" not in rv:
        return None, "msg missing call_id keys={list(rv.keys())}"
    i = rv.call_id
    if not isinstance(i, int):
        return None, f"msg call_id non-integer type={type(i)}"
    if i <= 0:
        return None, f"msg call_id non-positive call_id={i}"
    return rv, None
